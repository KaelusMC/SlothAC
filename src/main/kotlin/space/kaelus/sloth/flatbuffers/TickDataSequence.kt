/*
 * This file is part of SlothAC - https://github.com/KaelusMC/SlothAC
 * Copyright (C) 2026 KaelusMC
 *
 * SlothAC is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SlothAC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
// automatically generated by the FlatBuffers compiler, do not modify
package space.kaelus.sloth.flatbuffers

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.Table
import java.nio.ByteBuffer
import java.nio.ByteOrder

@Suppress("unused", "UnnecessaryParentheses")
class TickDataSequence : Table() {
  fun __init(_i: Int, _bb: ByteBuffer) {
    __reset(_i, _bb)
  }

  fun __assign(_i: Int, _bb: ByteBuffer): TickDataSequence {
    __init(_i, _bb)
    return this
  }

  fun ticks(j: Int): TickData? {
    return ticks(TickData(), j)
  }

  fun ticks(obj: TickData, j: Int): TickData? {
    val o = __offset(4)
    return if (o != 0) obj.__assign(__indirect(__vector(o) + j * 4), bb) else null
  }

  fun ticksLength(): Int {
    val o = __offset(4)
    return if (o != 0) __vector_len(o) else 0
  }

  fun ticksVector(): TickData.Vector? {
    return ticksVector(TickData.Vector())
  }

  fun ticksVector(obj: TickData.Vector): TickData.Vector? {
    val o = __offset(4)
    return if (o != 0) obj.__assign(__vector(o), 4, bb) else null
  }

  class Vector : BaseVector() {
    fun __assign(_vector: Int, _elementSize: Int, _bb: ByteBuffer): Vector {
      __reset(_vector, _elementSize, _bb)
      return this
    }

    fun get(j: Int): TickDataSequence {
      return get(TickDataSequence(), j)
    }

    fun get(obj: TickDataSequence, j: Int): TickDataSequence {
      return obj.__assign(__indirect(__element(j), bb), bb)
    }
  }

  companion object {
    @JvmStatic
    fun ValidateVersion() {
      Constants.FLATBUFFERS_25_2_10()
    }

    @JvmStatic
    fun getRootAsTickDataSequence(_bb: ByteBuffer): TickDataSequence {
      return getRootAsTickDataSequence(_bb, TickDataSequence())
    }

    @JvmStatic
    fun getRootAsTickDataSequence(_bb: ByteBuffer, obj: TickDataSequence): TickDataSequence {
      _bb.order(ByteOrder.LITTLE_ENDIAN)
      return obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)
    }

    @JvmStatic
    fun createTickDataSequence(builder: FlatBufferBuilder, ticksOffset: Int): Int {
      builder.startTable(1)
      addTicks(builder, ticksOffset)
      return endTickDataSequence(builder)
    }

    @JvmStatic
    fun startTickDataSequence(builder: FlatBufferBuilder) {
      builder.startTable(1)
    }

    @JvmStatic
    fun addTicks(builder: FlatBufferBuilder, ticksOffset: Int) {
      builder.addOffset(0, ticksOffset, 0)
    }

    @JvmStatic
    fun createTicksVector(builder: FlatBufferBuilder, data: IntArray): Int {
      builder.startVector(4, data.size, 4)
      for (i in data.size - 1 downTo 0) {
        builder.addOffset(data[i])
      }
      return builder.endVector()
    }

    @JvmStatic
    fun startTicksVector(builder: FlatBufferBuilder, numElems: Int) {
      builder.startVector(4, numElems, 4)
    }

    @JvmStatic
    fun endTickDataSequence(builder: FlatBufferBuilder): Int {
      return builder.endTable()
    }

    @JvmStatic
    fun finishTickDataSequenceBuffer(builder: FlatBufferBuilder, offset: Int) {
      builder.finish(offset)
    }

    @JvmStatic
    fun finishSizePrefixedTickDataSequenceBuffer(builder: FlatBufferBuilder, offset: Int) {
      builder.finishSizePrefixed(offset)
    }
  }
}
